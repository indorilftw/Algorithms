%{{{Header
\documentclass[a4paper,11pt]{article}
\usepackage{anysize}
\marginsize{2cm}{2cm}{1cm}{1cm}
%\textwidth 6.0in \textheight = 664pt
\usepackage{xltxtra}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xgreek}
\usepackage{framed}
\usepackage{float}
\usepackage{tkz-graph}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{enumitem}
\usepackage{relsize}
\setmainfont[Mapping=TeX-text]{DejaVu Serif}
\newcommand{\tab}{\hspace*{3em}}

%\setmainfont{Arial}
%\setsansfont{FreeSans}
%\setmonofont{FreeMono}
\begin{document}
%\def\thesubsection {\alph{subsection}}
\renewcommand{\labelenumi}{\roman{enumi})}
\renewcommand{\labelenumii}{ (\arabic{enumii}) }

\include{title/title}
%}}}

%{{{ 1) Παιχνίδι Επιλογής Ακμών σε Κατευθυνόμενο Ακυκλικό Γράφημα
\section{Παιχνίδι Επιλογής Ακμών σε Κατευθυνόμενο Ακυκλικό Γράφημα}
\setcounter{section}{1}

Αρχικά, φτιάχνουμε την τοπολογική διάταξη του DAG με χρήση DFS και δίνουμε
στους κόμβους αρχική τιμή 0, σε χρόνο $O(|V| + |E|)$. \emph{(0 = Lose
condition για τον Α, 1 = win condition)}. Αρχίζοντας από το τέλος του DAG και
πηγαίνοντας προς τα πίσω ελέγχουμε τους κόμβους.
\begin{itemize}
\item
Αν όλες οι εξερχόμενες ακμές τους είναι προς κόμβους με τιμή 1, τότε ο κόμβος
είναι lose condition για τον Α, οπότε σημειώνεται με 0 (Αφού αν βρεθεί σε
τέτοιο κόμβο ο Α, θα αναγκαστεί να προχωρήσει σε κόμβο που θα έχει winning
strategy o B).
\item
Αλλιώς, υπάρχει κόμβος που οδηγεί σε lose condition (0) για τον Β, άρα ο κόμβος
αυτός είναι νικηφόρος για τον Α.
\end{itemize}

Υπάρχει νικηφόρα στρατηγική για τον Α, αν ο κόμβος έναρξης είναι νικηφόρος
μετά την εκτέλεση του αλγορίθμου.

\begin{algorithm}[H]
\caption{DAG traversing game}
\begin{algorithmic}[1]
\Procedure{Traverse}{$(G(V,E),s)$}
	\State \emph{Make topological sorting of G}
    \For{\textbf{all} $u \in G$}
		\State $C[u] \gets 0$.
	\EndFor
    \For{\textbf{all} $u \in G$, \emph{starting from the end -> start}}
		\For{\textbf{all} $e[u,v] \in AdjList(u)$}
			\If {$C[v] = 0$}
				\State $C[u] \gets 1$
			\EndIf
		\EndFor
	\EndFor
	\If{$C[s] = 1$}
		\State \textbf{return} Win
	\Else
		\State \textbf{return} Lose
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

Η πολυπλοκότητα του αλγορίθμου είναι $O(|V| + |E|)$ αφού τόσο το DFS όσο και
το σώμα του αλγορίθμου εξετάζουν από μία φορά κάθε κόμβο και ακμή.

%}}}

%{{{ 2) Σχεδιασμός Ταξιδιού (DPV 4.13)
\section{Σχεδιασμός Ταξιδιού (DPV 4.13)}
\begin{enumerate}
\item Μία τέτοια διαδρομή είναι εφικτό να βρεθεί (ή να αποδειχτεί η μη ύπαρξή
της) σε γραμμικό χρόνο. Κάνοντας ένα BFS στο γράφημα απορρίπτωντας κάθε ακμή η
οποία έχει βάρος $w > L$ βρίσκουμε μία τέτοια διαδρομή, αν υπάρχει σε χρόνο
$O(|E| + |V|)$.
\item Για να υπολογίσουμε την ελάχιστη αυτονομία θα χρησιμοποιήσουμε μια
τροποποιημένη μορφή του αλγορίθμου του Dikjstra. Όπως ο Dijkstra κρατάει ώς
δεδομένο την ελάχιστη απόσταση ώς ένα κόμβο και "αναπτύσσει" τον κόμβο με τη
λιγότερη απόσταση, εδώ θα κρατάμε ώς δεδομένο την ελάχιστη αυτονομία καυσίμου
(το ελάχιστο από τα μέγιστα βάρη ακμών) για να φτάσουμε σε ένα κόμβο και θα
συνεχίζουμε την αναζήτηση από τον κόμβο με τη μικρότερη τιμή. Δηλαδή:
\begin{algorithm}[H]
\caption{Minimum tank capacity}
\begin{algorithmic}[1]
\Procedure{minCapacity}{$(G(V,E,w)s,t)$}
    \For{\textbf{all} $u \in V$}
	    \State $D[u] \gets \infty$
	\EndFor
	\State $D[s] \gets 0 ; S \gets \emptyset$
	\While {$|S| < |V|$}
	    \State $u \notin S : D[u] = min_{v \notin S}\{D[v]\}$
		\State $S \gets S \cup \{u\}$
	\EndWhile
    \For{\textbf{all} $v \in AdjList[u]$}
		\If {$D[v] > max(D[u], w[u,v])$}
			\State $D[v] \gets max(D[u], w[u,v])$
		\EndIf
	\EndFor
	\State \textbf{return} D[t]
\EndProcedure
\end{algorithmic}
\end{algorithm}

Ο αλγόριθμος αυτός έχει πολυπλοκότητα $O(|E|log|V|)$ (με binary heaps) ή
$O(|E| + |V|log|V|)$ (με fibonacci heaps), όσο η εκτέλεση του αλγορίθμου του
Dijkstra
\end{enumerate}


%}}}

%{{{ 3) Διαχωρισμός Γραφήματος
\section{Διαχωρισμός Γραφήματος}

\begin{enumerate}
\item Έστω ότι δεν είναι το συντομότερο μονοπάτι. Θα υπάρχει δηλαδή μια ακμή
$e' \notin T$ με $w(e') < w(e)$, που ακουμπάει στον κόμβο u. Αυτό είναι άτοπο,
αφού ο αλγόριθμος του Kruskal (που ταξινομεί τις ακμές) θα την είχε επιλέξει
για το MST προτού επεξεργαστεί την e που θεωρούμε πως ανήκει στο MST.
\item Υπολογίζουμε το MST T με έναν από τους γνωστούς αλγορίθμους (σε ελάχιστο
χρόνο $O(|E| + |V|log|V|$). Στη συνέχεια βρίσκουμε σε γραμμικό χρόνο τη
μεγαλύτερου βάρους ακμή και την αφαιρούμε από το T. Οι κόμβοι στις 2
συνεκτικές συνιστώσες που προκύπτουν ανήκουν στα υποσύνολα $S_1, S_2$ της
επιθυμητής διαμέρισης.

Το βέλτιστο της επιλογής μας προκύπτει λογικα: Οι μεγαλύτερου βάρους ακμές που
δεν είναι αναγκαίες για τη συνεκτικότητα του δέντρου αφαιρούνται από τη
διαδικασία εύρεσης του MST. Σκοπός μας είναι να χωρίσουμε το γράφο σε 2
συνιστώσες, μεγιστοποιώντας την απόσταση μεταξύ των συνιστωσών. Το ελάχιστο
κόστος που μπορούμε λοιπόν να "πληρώσουμε" είναι όσο μια ακμή που ανήκει στο
MST, και για να μεγιστοποιήσουμε αυτή την ποσότητα, επιλέγουμε τη μέγιστη.
\end{enumerate}

%}}}

%{{{ 4) Παιχνίδια Εξουσίας
\section{Παιχνίδια εξουσίας}
\begin{enumerate}
\item Θεωρούμε το διμερές γράφημα, όπου αριστερά υπάρχουν οι n κορυφές των
ιπποτών και δεξιά οι m πύργοι. Οι λίστες $K_j$ των πύργων ορίζουν την ύπαρξη
των κατευθυνόμενων ακμών από τους αντίστοιχους ιππότες.

Για κάθε ιππότη i θέτουμε το βάρος της κάθε εξερχόμενης ακμής ίσο με $1/c_i$.
Με αυτό τον τρόπο, θα εμποδιστεί η ανάθεση παραπάνω από $c_i$ καστρών.

Τέλος, δημιουργούμε αριστερά από τους κόμβους των ιπποτών μια πηγή s που
τροφοδοτεί τον καθένα με ακμή βάρους 1, και δεξιά από τους κόμβους των πύργων
μία καταβόθρα t, που δέχεται από κάθε πύργο ακμή βάρους 1. Aφού κάθε ιππότης
δέχεται ροή 1 και έχει εξερχόμενες ακμές βάρους $1/c_i$ δε μπορεί να ανατεθεί
σε περισσότερα απο $c_i$ κάστρα.

Έπειτα, εφαρμόζω στο γράφο τον αλγόριθμο των Edmonds-Karp για υπολογισμό του
Max Flow, και καταμετρώ το πλήθος k των ακμών που χρησιμοποιήθηκαν. Αν το k
ισούται με τον αριθμό m των καστρών, τότε αποφαινόμαστε ότι υπάρχει τέτοια
ανάθεση.

Η πολυπλοκότητα του αλγορίθμου είναι $O(|V|^2 * |E|)$, όσο του γνωστού
αλγορίθμου.

\item

\item Θεωρώντας ότι κάθε ιππότης αντιστοιχεί σε ένα κόμβο και κάθε διένεξη των
ιπποτών σε μια ακμή μεταξύ των κόμβων, το πρόβλημα απομάκρυνσης ελαχίστου
πλήθους ιπποτών ώστε να μην υπάρχουν συγκρούσεις ταυτίζεται με την εύρεση του
maximum independent set του γράφου που προκύπτει. Το πρόβλημα είναι
αποδεδειγμένα NP-complete, επομένως δεν υπάρχει αποδοτικός αλγόριθμος για την
επίλυσή του.

Η σωστότερη απάντηση του πρωθυπουργού είναι να παραδεχτεί ότι δεν μπορεί,
ισχυριζόμενος βέβαια ότι κανείς για πολλούς αιώνες στο μέλλον (τότε που οι
άνθρωποι θα κάνουν πολλούς και γρήγορους υπολογισμούς σε κάτι κουτιά που θα
αποκαλούν "υπολογιστές"), ίσως ακόμα και ποτέ, δε θα καταφέρει να το επιλύσει.

\end{enumerate}

%}}}

%{{{ 5) Αναγωγές και NP-Πληρότητα
\section{Αναγωγές και NP-Πληρότητα}
\subsection{Dense subgraph}
Θα ανάγουμε το πρόβλημα του Max Clique στο k-Dense Subgraph.

Έστω ότι υπάρχει αλγόριθμος Α που λύνει το k-DS στο γράφο G.
Θα δείξουμε ότι ο αλγόριθμος αυτός μπορεί να δώσει απάντηση για το Max Clique
n κορυφών.

Δίνουμε ως είσοδος το γράφο G, και θέτουμε $k = n$ και $b = \frac{n(n-1)}{2}$.
Τότε o αλγόριθμος απαντάει:
\begin{itemize}
\item Ναι, \underline{αν και μόνο αν} υπάρχει κλίκα με n κορυφές. Αφού υπάρχει
σύνολο n κορυφών με τουλάχιστον (ακριβώς) $\frac{n(n-1)}{2}$ ακμές, όσες είναι
το μέγιστο δυνατό πλήθος ακμών σε πλήρες γράφημα, άρα υπάρχει κλίκα.
\item Όχι, \underline{αν και μόνο αν} δεν υπάρχει κλίκα με n κορυφές, αφού δεν
υπάρχει σύνολο n κορυφών με τουλάχιστον $\frac{n(n-1)}{2}$ ακμές.
\end{itemize}

\subsection{Μακρύ μονοπάτι}
Θα ανάγουμε το πρόβλημα του Hamiltonian Path στο Longest Path.

Έστω ότι υπάρχει αλγόριθμος Α που λύνει το LongestPath σε γράφο G'.
Θα δείξουμε ότι ο αλγόριθμος αυτός μπορεί να δώσει απάντηση για το Hamiltonian
Path για γράφο G.

Δίνουμε ως είσοδος στον αλγόριθμο το γράφο G'(2V,E), που είναι ο γράφος G(V,E)
για τον οπόιο ψάχνουμε για την ύπαρξη Hamiltonian Path, με την προσθήκη V στο
πλήθος ξένων κορυφών που δεν έχουν εφαπτόμενες ακμές.
Τότε o αλγόριθμος απαντάει:
\begin{itemize}
\item Ναι, \underline{αν και μόνο αν} υπάρχει μονοπάτι που διέρχεται από τις V
κορυφές (του αρχικού γράφου) ακριβώς μία φορά, άρα υπάρχει μονοπάτι Hamilton.
\item Όχι, \underline{αν και μόνο αν} δεν υπάρχει τέτοιο μονοπάτι, άρα δεν
υπάρχει και μονοπάτι Hamilton.
\end{itemize}

\subsection{Feedback Vertex Set - Directed}
Θα ανάγουμε το πρόβλημα του Vertex Cover στο directed FVS.

Έστω ότι υπάρχει αλγόριθμος που λύνει το directed FVS σε ένα γράφο G.
Θα δείξουμε ότι μπορεί να χρησιμοποιηθεί για να λυθεί το Vertex Cover.

Θεωρούμε το γράφο G', που περιέχει τους κόμβους V του G, αλλά κάθε ακμή
$e(u,v)$ έχει αντικατασταθεί με 2 αντίθετης κατεύθυνσης ακμές μεταξύ των 2
κόμβων ($e_1(u,v), e_2(v,u)$), δημιουργώντας 'κύκλους' σε κάθε ακμή.
Τότε ο αλγόριθμος απαντάει:
\begin{itemize}
\item Ναι, \underline{αν και μόνο αν} υπάρχει σύνολο το πολύ k κορυφών ώστε να
μην υπάρχουν κύκλοι στο γράφημα, άρα (με τον τρόπο που δημιουργήθηκαν παραπάνω
οι κύκλοι) επικαλύπτονται όλες οι ακμές, άρα υπάρχει Vertex Cover $\leq$ k.
\item Όχι, \underline{αν και μόνο αν} δεν υπάρχει ένα τέτοιο σύνολο, άρα δεν
υπάρχει και Vertex Cover $\leq$ k.
\end{itemize}

\subsection{Feedback Vertex Set - Undirected}
Θα ανάγουμε το πρόβλημα του Vertex Cover στο undirected FVS.

Έστω ότι υπάρχει αλγόριθμος που λύνει το undirected FVS σε ένα γράφο G.
Θα δείξουμε ότι μπορεί να χρησιμοποιηθεί για να λυθεί το Vertex Cover.

Θεωρούμε το γράφο G', που περιέχει τους κόμβους V του G, αλλά κάθε ακμή
$e(u,v)$ έχει αντικατασταθεί με 1 "dummy" κόμβο που έχει ακμές προς τις
κορυφές u και v (δημιουργώντας έτσι κύκλους).
Τότε ο αλγόριθμος απαντάει:
\begin{itemize}
\item Ναι, \underline{αν και μόνο αν} υπάρχει σύνολο το πολύ k κορυφών ώστε να
μην υπάρχουν κύκλοι στο γράφημα.\\ Αν όλες οι επιλεγμένες κορυφές ανήκουν στον
G, τότε εύκολα προκύπτει ότι υπάρχει Vertex Cover $\leq$ k. Αν στο σύνολο
υπάρχουν κορυφές από τις "dummy" που δημιουργήσαμε, τότε τις αντικαθιστούμε με
μία από τις γειτονικές τους, ενώ το πλήθος των k κορυφών δεν αυξάνεται,
αντίθετα, δυνητικά μειώνεται επιπλέον. Άρα πάλι υπάρχει Vertex Cover $\leq$ k.
\item Όχι, \underline{αν και μόνο αν} δεν υπάρχει ένα τέτοιο σύνολο, άρα δεν
υπάρχει και Vertex Cover $\leq$ k.
\end{itemize}

%}}}

\end{document}
