%{{{Header
\documentclass[a4paper,11pt]{article}
\usepackage{anysize}
\marginsize{2cm}{2cm}{1cm}{1cm}
%\textwidth 6.0in \textheight = 664pt
\usepackage{xltxtra}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xgreek}
\usepackage{framed}
\usepackage{float}
\usepackage{tkz-graph}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{enumitem}
\usepackage{relsize}
\setmainfont[Mapping=TeX-text]{DejaVu Serif}
\newcommand{\tab}{\hspace*{3em}}

%\setmainfont{Arial}
%\setsansfont{FreeSans}
%\setmonofont{FreeMono}
\begin{document}
%\def\thesubsection {\alph{subsection}}
\renewcommand{\labelenumi}{\roman{enumi})}
\renewcommand{\labelenumii}{ (\arabic{enumii}) }

\include{title/title}
%}}}

%{{{ 1) Παιχνίδι Επιλογής Ακμών σε Κατευθυνόμενο Ακυκλικό Γράφημα
\section{Παιχνίδι Επιλογής Ακμών σε Κατευθυνόμενο Ακυκλικό Γράφημα} \setcounter{section}{1}

Αρχικά, φτιάχνουμε την τοπολογική διάταξη του DAG με χρήση DFS και δίνουμε
στους κόμβους αρχική τιμή 0, σε χρόνο $O(|V| + |E|)$. \emph{(0 = Lose
condition για τον Α, 1 = win condition)}. Αρχίζοντας από το τέλος του DAG και
πηγαίνοντας προς τα πίσω ελέγχουμε τους κόμβους.
\begin{itemize}
\item
Αν όλες οι εξερχόμενες ακμές τους είναι προς κόμβους με τιμή 1, τότε ο κόμβος
είναι lose condition για τον Α, οπότε σημειώνεται με 0.
\item
Αλλιώς, υπάρχει κόμβος που οδηγεί σε lose condition (0) για τον Β, άρα ο κόμβος
αυτός είναι νικηφόρος για τον Α.
\end{itemize}

Υπάρχει νικηφόρα στρατηγική για τον Α, αν ο κόμβος έναρξης είναι νικηφόρος
μετά την εκτέλεση του αλγορίθμου.

\begin{algorithm}[H]
\caption{DAG traversing game}
\begin{algorithmic}[1]
\Procedure{Traverse}{$(G(V,E),s)$}
	\State \emph{Make topological sorting of G}
    \For{\textbf{all} $u \in G$}
		\State $C[u] \gets 0$.
	\EndFor
    \For{\textbf{all} $u \in G$, \emph{starting from the end -> start}}
		\For{\textbf{all} $e[u,v] \in AdjList(u)$}
			\If {$C[v] = 0$}
				\State $C[u] \gets 1$
			\EndIf
		\EndFor
	\EndFor
	\If{$C[s] = 1$}
		\State \textbf{return} Win
	\Else
		\State \textbf{return} Lose
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

Η πολυπλοκότητα του αλγορίθμου είναι $O(|V| + |E|)$ αφού τόσο το DFS όσο και
το σώμα του αλγορίθμου εξετάζουν από μία φορά κάθε κόμβο και ακμή.

%}}}

%{{{ 2) Σχεδιασμός Ταξιδιού (DPV 4.13)
\section{Σχεδιασμός Ταξιδιού (DPV 4.13)}
\begin{enumerate}
\item Μία τέτοια διαδρομή είναι εφικτό να βρεθεί (ή να αποδειχτεί η μη ύπαρξή
της) σε γραμμικό χρόνο. Κάνοντας ένα BFS στο γράφημα απορρίπτωντας κάθε ακμή η
οποία έχει βάρος $w > L$ βρίσκουμε μία τέτοια διαδρομή, αν υπάρχει σε χρόνο
$O(|E| + |V|)$.
\item Για να υπολογίσουμε την ελάχιστη αυτονομία θα χρησιμοποιήσουμε μια
τροποποιημένη μορφή του αλγορίθμου του Dikjstra. Όπως ο Dijkstra κρατάει ώς
δεδομένο την ελάχιστη απόσταση ώς ένα κόμβο και "αναπτύσσει" τον κόμβο με τη
λιγότερη απόσταση, εδώ θα κρατάμε ώς δεδομένο την ελάχιστη αυτονομία καυσίμου
(το ελάχιστο από τα μέγιστα βάρη ακμών) για να φτάσουμε σε ένα κόμβο και θα
συνεχίζουμε την αναζήτηση από τον κόμβο με τη μικρότερη τιμή. Δηλαδή:
\begin{algorithm}[H]
\caption{Minimum tank capacity}
\begin{algorithmic}[1]
\Procedure{minCapacity}{$(G(V,E,w)s,t)$}
    \For{\textbf{all} $u \in V$}
	    \State $D[u] \gets \infty$
	\EndFor
	\State $D[s] \gets 0 ; S \gets \emptyset$
	\While {$|S| < |V|$}
	    \State $u \notin S : D[u] = min_{v \notin S}\{D[v]\}$
		\State $S \gets S \cup \{u\}$
	\EndWhile
    \For{\textbf{all} $v \in AdjList[u]$}
		\If {$D[v] > max(D[u], w[u,v])$}
			\State $D[v] \gets max(D[u], w[u,v])$
		\EndIf
	\EndFor
	\State \textbf{return} D[t]
\EndProcedure
\end{algorithmic}
\end{algorithm}

Ο αλγόριθμος αυτός έχει πολυπλοκότητα $O(|E|log|V|)$ (με binary heaps) ή
$O(|E| + |V|log|V|)$ (με fibonacci heaps), όσο η εκτέλεση του αλγορίθμου του
Dijkstra
\end{enumerate}


%}}}

%{{{ 3) Διαχωρισμός Γραφήματος
\section{Διαχωρισμός Γραφήματος}

\begin{enumerate}
\item Έστω ότι δεν είναι το συντομότερο μονοπάτι. Θα υπάρχει δηλαδή μια ακμή
$e' \notin T$ με $w(e') < w(e)$, που ακουμπάει στον κόμβο u. Αυτό είναι άτοπο,
αφού ο αλγόριθμος του Kruskal (που ταξινομεί τις ακμές) θα την είχε επιλέξει
για το MST προτού επεξεργαστεί την e που θεωρούμε πως ανήκει στο MST.
\item Υπολογίζουμε το MST T με έναν από τους γνωστούς αλγορίθμους (σε ελάχιστο
χρόνο $O(|E| + |V|log|V|$). Στη συνέχεια βρίσκουμε σε γραμμικό χρόνο τη
μεγαλύτερου βάρους ακμή και την αφαιρούμε από το T. Οι κόμβοι στις 2
συνεκτικές συνιστώσες που προκύπτουν ανήκουν στα υποσύνολα $S_1, S_2$ της
επιθυμητής διαμέρισης.

Το βέλτιστο της επιλογής μας προκύπτει λογικα: Οι μεγαλύτερου βάρους ακμές που
δεν είναι αναγκαίες για τη συνεκτικότητα του δέντρου αφαιρούνται από τη
διαδικασία εύρεσης του MST. Σκοπός μας είναι να χωρίσουμε το γράφο σε 2
συνιστώσες, μεγιστοποιώντας την απόσταση μεταξύ των συνιστωσών. Το ελάχιστο
κόστος που μπορούμε λοιπόν να "πληρώσουμε" είναι όσο μια ακμή που ανήκει στο
MST, και για να μεγιστοποιήσουμε αυτή την ποσότητα, επιλέγουμε τη μέγιστη.
\end{enumerate}

%}}}

%{{{ 4) Παιχνίδια Εξουσίας
\section{Παιχνίδια εξουσίας}
FILL ME 4!

%}}}

%{{{ 5) Αναγωγές και NP-Πληρότητα
\section{Αναγωγές και NP-Πληρότητα}
\subsection{Dense subgraph}
Dense fill!
\subsection{Μακρύ μονοπάτι}
Μακρύ indeed!
\subsection{Feedback Vertex Set - Directed}
directed!
\subsection{Feedback Vertex Set - Undirected}
undirected!

%}}}

\end{document}
